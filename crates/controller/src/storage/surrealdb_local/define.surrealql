-- storage object table
DEFINE TABLE IF NOT EXISTS storage_object SCHEMAFULL;

DEFINE FIELD IF NOT EXISTS descriptor ON storage_object TYPE object;
DEFINE FIELD IF NOT EXISTS meta ON storage_object TYPE object;
DEFINE FIELD IF NOT EXISTS data ON storage_object TYPE bytes;
DEFINE FIELD IF NOT EXISTS descriptor.id ON storage_object TYPE string;
DEFINE FIELD IF NOT EXISTS descriptor.revision ON storage_object TYPE string;
DEFINE FIELD IF NOT EXISTS meta.created_at ON storage_object TYPE datetime;
DEFINE FIELD IF NOT EXISTS meta.data_type ON storage_object TYPE string;

DEFINE INDEX IF NOT EXISTS index_descriptor_id ON storage_object FIELDS descriptor.id;
DEFINE INDEX IF NOT EXISTS index_descriptor_revision ON storage_object FIELDS descriptor.revision;
DEFINE INDEX IF NOT EXISTS index_descriptor ON storage_object FIELDS descriptor.revision, descriptor.id;
DEFINE INDEX IF NOT EXISTS index_meta_data_type ON storage_object FIELDS meta.data_type;

-- latest index for storage objects
DEFINE TABLE IF NOT EXISTS storage_object_latest SCHEMAFULL;

DEFINE FIELD IF NOT EXISTS id ON storage_object_latest TYPE string;
DEFINE FIELD IF NOT EXISTS revision ON storage_object_latest TYPE string;
DEFINE FIELD IF NOT EXISTS object ON storage_object_latest TYPE record;

DEFINE INDEX IF NOT EXISTS unique_id ON storage_object_latest COLUMNS id UNIQUE;

-- save object and update latest index
DEFINE FUNCTION IF NOT EXISTS fn::storage_object::save($content: object) -> object {
    $id = rand::ulid();
    LET $record = UPSERT ONLY type::thing("storage_object", $id) CONTENT $content;
    UPSERT storage_object_latest CONTENT { id: $record.descriptor.id, revision: $record.descriptor.revision, object: $record.id };
    RETURN $record.descriptor;
};

DEFINE FUNCTION IF NOT EXISTS fn::storage_object::get($descriptor: object) -> option<object> {
    LET $record = SELECT * FROM ONLY storage_object WHERE descriptor.id = $descriptor.id AND descriptor.revision = $descriptor.revision;
    RETURN IF ($record IS NONE) {
        NONE;
    } ELSE {
        $record;
    };
};

DEFINE FUNCTION IF NOT EXISTS fn::storage_object::delete($descriptor: object) -> object {
    LET $record = SELECT * FROM ONLY storage_object WHERE descriptor.id = $descriptor.id AND descriptor.revision = $descriptor.revision;
    IF ($record IS NONE) {
        RETURN NONE;
    };
    LET $latest = SELECT * FROM ONLY storage_object_latest WHERE id = type::thing("storage_object_latest", $descriptor.id);
    IF ($latest.revision == $descriptor.revision) {
        DELETE storage_object_latest WHERE id = type::thing("storage_object_latest", $descriptor.id);
    };
    DELETE storage_object WHERE descriptor.id = $descriptor.id AND descriptor.revision = $descriptor.revision;
    RETURN $descriptor;
};

DEFINE FUNCTION IF NOT EXISTS fn::storage_object::list($filter: object, $limit: int, $cursor: option<string>) -> array {
    RETURN IF ($filter.latest_only == TRUE) {
        (SELECT object.descriptor as descriptor, object.meta as meta, object.id as id FROM storage_object_latest
            WHERE
                ($filter.data_type IS NONE OR object.meta.data_type == $filter.data_type)
                AND ($filter.id IS NONE OR object.descriptor.id == $filter.id)
                AND ($filter.revision IS NONE OR object.descriptor.revision == $filter.revision)
                AND ($filter.created_after IS NONE OR object.meta.created_at >= $filter.created_after)
                AND ($filter.created_before IS NONE OR object.meta.created_at <= $filter.created_before)
                AND ($cursor IS NONE OR object.id < type::thing("storage_object", $cursor))
            ORDER BY object.id ASC
            LIMIT $limit)
    } ELSE {
        (SELECT descriptor, meta, id FROM storage_object
            WHERE
                ($filter.data_type IS NONE OR meta.data_type == $filter.data_type)
                AND ($filter.id IS NONE OR descriptor.id == $filter.id)
                AND ($filter.revision IS NONE OR descriptor.revision == $filter.revision)
                AND ($filter.created_after IS NONE OR meta.created_at >= $filter.created_after)
                AND ($filter.created_before IS NONE OR meta.created_at <= $filter.created_before)
                AND ($cursor IS NONE OR id < type::thing("storage_object", $cursor))
            ORDER BY id ASC
            LIMIT $limit)
    };
};


DEFINE FUNCTION IF NOT EXISTS fn::storage_object::delete_by_id($object_id: string) {
    LET $latest = SELECT * FROM ONLY storage_object_latest WHERE id = type::thing("storage_object_latest", $object_id);
    IF ($latest IS NOT NONE) {
        DELETE storage_object_latest WHERE id = type::thing("storage_object_latest", $object_id);
    };
    DELETE storage_object WHERE descriptor.id = $object_id;
};

DEFINE FUNCTION IF NOT EXISTS fn::storage_object::batch_delete($descriptors: array<object>) {
    DELETE FROM storage_object WHERE descriptor IN $descriptors;
    LET $affected_ids = array::distinct(array::map($descriptors, | $deleted | type::thing("storage_object_latest", $affected_id)));
    FOR $affected_id IN $affected_ids {
        LET $latest = SELECT * FROM ONLY storage_object_latest WHERE id = $affected_ids;
        LET $current_latest = SELECT descriptor, id FROM ONLY storage_object WHERE descriptor.id = $affected_id ORDER BY id DESC LIMIT 1;
        IF ($current_latest IS NONE) {
            DELETE storage_object_latest WHERE id = $affected_id;
        } ELSE IF ($latest.revision != $current_latest.descriptor.revision) {
            UPSERT storage_object_latest CONTENT { id: $affected_id, revision: $current_latest.descriptor.revision, object: type::thing("storage_object_latest", $current_latest.id) };
        };
    };
};